plugins {
	id 'com.android.application'
}

android {
	compileSdk 31

	defaultConfig {
		applicationId "is.xyz.vcmi"
		minSdk 19
		targetSdk 31
		versionCode 1103
		versionName "1.1"
		setProperty("archivesBaseName", "vcmi")

		externalNativeBuild {
			cmake {
				version "3.18+"
				arguments "-DANDROID_STL=${VCMI_STL_VERSION}",
					"-DANDROID_NATIVE_API_LEVEL=${VCMI_PLATFORM}",
					"-DANDROID_TOOLCHAIN=clang",
					"-DVCMI_ROOT=${PROJECT_PATH_BASE}"
				cppFlags "-frtti", "-fexceptions", "-Wno-switch"
			}
		}
		ndk {
			abiFilters = new HashSet<>()
			abiFilters.addAll(VCMI_ABIS)
		}
	}
	
	signingConfigs {
        releaseSigning
        LoadSigningConfig(PROJECT_PATH_BASE)
    }

	sourceSets {
		main {
			jniLibs.srcDirs = ["${PROJECT_PATH_BASE}/ext-output"]
		}
	}

	buildTypes {
		release {
			minifyEnabled false
			zipAlignEnabled true
			signingConfig signingConfigs.releaseSigning
			proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
		}
	}

	applicationVariants.all { variant -> RenameOutput(project.archivesBaseName, variant) }

	tasks.withType(JavaCompile) {
		options.compilerArgs += ["-Xlint:deprecation"]
	}
	
	compileOptions {
		sourceCompatibility JavaVersion.VERSION_1_8
		targetCompatibility JavaVersion.VERSION_1_8
	}
	
	externalNativeBuild {
		cmake {
			version "3.18.0+"
			path file('cmake-scripts/CMakeLists.txt')
		}
	}
	
	buildFeatures {
		viewBinding true
		dataBinding true
	}
	
	flavorDimensions "vcmi"
	productFlavors {
		VcmiOnly {
			dimension "vcmi"
			externalNativeBuild {
				cmake {
					version "3.18+"
					targets "vcmi",
							"vcmiserver",
							"vcmiclient"
				}
			}
		}
		LibsOnly {
			dimension "vcmi"
			externalNativeBuild {
				cmake {
					version "3.18+"
					targets "boost-datetime",
							"boost-system",
							"boost-filesystem",
							"boost-locale",
							"boost-program-options",
							"boost-thread",
							"fl-shared",
							"minizip"
				}
			}
		}
		AllTargets {
			dimension "vcmi"
			externalNativeBuild {
				cmake {
					version "3.18+"
					targets "boost-datetime",
							"boost-system",
							"boost-filesystem",
							"boost-locale",
							"boost-program-options",
							"boost-thread",
							"fl-shared",
							"minizip",
							"vcmi",
							"vcmiserver",
							"vcmiclient"
				}
			}
		}
	}
}

def RenameOutput(final baseName, final variant) {
	final def buildTaskId = System.getenv("GITHUB_RUN_ID")

	ResolveGitInfo()

	def name = baseName + "-" + ext.gitInfoLauncher + "-" + ext.gitInfoVcmi

    if (buildTaskId != null && !buildTaskId.isEmpty()) {
        name = buildTaskId + "-" + name
    }

    if (!variant.buildType.name != "release") {
        name += "-" + variant.buildType.name
    }

	variant.outputs.each { output ->
        def oldPath = output.outputFile.getAbsolutePath()
		output.outputFileName = name + oldPath.substring(oldPath.lastIndexOf("."))
	}
}

def CommandOutput(final cmd, final arguments, final cwd) {
    try {
        new ByteArrayOutputStream().withStream { final os ->
            exec {
                executable cmd
                args arguments
                workingDir cwd
                standardOutput os
            }
            return os.toString().trim()
        }
    }
    catch (final Exception ex) {
        print("Broken: " + cmd + " " + arguments + " in " + cwd + " :: " + ex.toString())
        return ""
    }
}

def ResolveGitInfo() {
    if (ext.gitInfoLauncher != "none" && ext.gitInfoVcmi != "none") {
        return
    }
    ext.gitInfoLauncher = CommandOutput("git", ["describe", "--match=", "--always", "--abbrev=7"], PROJECT_PATH_BASE)
    ext.gitInfoVcmi =
            CommandOutput("git", ["log", "-1", "--pretty=%D", "--decorate-refs=refs/remotes/origin/*"], PROJECT_PATH_BASE + "/ext/vcmi").replace("origin/", "").replace(", HEAD", "").replaceAll("[^a-zA-Z0-9\\-_]", "_") +
                    "-" +
                    CommandOutput("git", ["describe", "--match=", "--always", "--abbrev=7"], PROJECT_PATH_BASE + "/ext/vcmi")
}

def SigningPropertiesPath(final basePath) {
    return file(basePath + "/.github/CI/signing.properties")
}

def SigningKeystorePath(final basePath, final keystoreFileName) {
    return file(basePath + "/.github/CI/" + keystoreFileName)
}

def LoadSigningConfig(final basePath) {
    final def props = new Properties()
    final def propFile = SigningPropertiesPath(basePath)
    if (propFile.canRead()) {
        props.load(new FileInputStream(propFile))

        if (props != null
                && props.containsKey('STORE_FILE')
                && props.containsKey('STORE_PASSWORD')
                && props.containsKey('KEY_ALIAS')
                && props.containsKey('KEY_PASSWORD')) {

            android.signingConfigs.releaseSigning.storeFile = SigningKeystorePath(basePath, props['STORE_FILE'])
            android.signingConfigs.releaseSigning.storePassword = props['STORE_PASSWORD']
            android.signingConfigs.releaseSigning.keyAlias = props['KEY_ALIAS']
            android.signingConfigs.releaseSigning.keyPassword = props['KEY_PASSWORD']
        } else {
            println("Some props from signing file are missing")
            android.buildTypes.release.signingConfig = null
        }
    } else {
        println("file with signing properties is missing")
        android.buildTypes.release.signingConfig = null
    }
}

dependencies {
	implementation 'androidx.appcompat:appcompat:1.2.0'
	implementation 'com.google.android.material:material:1.3.0'
	implementation 'androidx.constraintlayout:constraintlayout:2.0.4'
}